# Copyright (C) 2022 Rochus Keller (me@rochus-keller.ch) for LeanQt
# licensed under GPL/LGPL

let lib_config : Config {
	.defines += [
		"QT_BUILD_CORE_LIB" # required to make resource system work at all
	]
}

let core_config * : Config {
	.include_dirs += [
		abspath() + ../includes 
		abspath() + ../includes/QtCore
		abspath()
	]
	.defines += [
		# these are official Qt defines
		"QT_NO_BIG_CODECS"
		"QT_NO_ICONV"
		"QT_NO_ANIMATION"
		#"QT_USE_QSTRINGBUILDER" # not used in the Qt installations I'm using; can be put locally in a file if needed
		"QT_CRYPTOGRAPHICHASH_ONLY_SHA1" # includes MD5
		"QT_NO_COMPRESS"
		"QT_ATOMIC_FORCE_NO_CXX11"
		"QT_NO_VERSION_TAGGING"
	]
	.defines += [
		"QT_NO_ITEMMODELS"
		"QT_NO_PLUGINS" # plugins require HAVE_OBJECTS and HAVE_JSON
	]
	
	if !^HAVE_LIBRARY {
		.defines += "QT_NO_LIBRARY"
	}
	
	if ^HAVE_SHARED {
		.defines += "QT_SHARED"
		# QT_STATIC is automatically set in qconfig.h
	}
	
	if !^HAVE_GEOM {
		.defines += "QT_NO_GEOM_VARIANT"
	}
	
	if !^HAVE_URL {
		.defines += "QT_NO_URL_VARIANT"
	}

	if !^HAVE_RE {
		.defines += "QT_NO_REGULAREXPRESSION"
	}
	
	if !^HAVE_JSON {
		.defines += "QT_NO_JSON"
	}
	
	if !^HAVE_DSTREAM {
		.defines += "QT_NO_DATASTREAM"
	}
	
	if !^HAVE_FILEIO {
		.defines += "QT_NO_FILEENGINE"
	}
	
	if !^HAVE_OBJECT {
		.defines += "QT_NO_QOBJECT"
	}
	
	if !^HAVE_COREAPP {
		.defines += "QT_NO_COREAPPLICATION"
	}
	
	if !^HAVE_THREADS {
		.defines += "QT_NO_THREAD"
	}
	
	if target_os == `win32 {
		.defines += [ "UNICODE" "_UNICODE" ]
		if target_toolchain == `msvc {
			.cflags_cc += [ "/EHsc" "/Zc:wchar_t" "-Zc:strictStrings" "/GR" ]
		}
	}else if target_os == `macos {
        .defines += "QT_NO_THREADSAFE_CLOEXEC"
    }
}

let sources* : SourceSet {
	.sources += [
		./qbytearray.cpp
		./qarraydata.cpp
		./qbytearraymatcher.cpp
		./qbuffer.cpp
		./qiodevice.cpp
		./qlogging.cpp
		./qloggingcategory.cpp
		./qloggingregistry.cpp
		./qstring.cpp 
		./qglobal.cpp
		./qglobalstatic.cpp
		./qstring_compat.cpp
		./qregexp.cpp
		./qmap.cpp
		./qlist.cpp
		./qhash.cpp
		./qtextstream.cpp
		./qtextcodec.cpp
		./qsimplecodec.cpp
		./qutfcodec.cpp
		./qlatincodec.cpp
		./qcoreglobaldata.cpp
		./qlocale.cpp
		./qlocale_tools.cpp
		./qdatetime.cpp
		./qtimezone.cpp
		./qtimezoneprivate.cpp
		./qvariant.cpp
		./qmetatype.cpp
		./qdebug.cpp
		./qipaddress.cpp
		./qstringlist.cpp
		./qdatetimeparser.cpp
		./qnumeric.cpp
		./qmalloc.cpp
		./quuid.cpp
		./qcryptographichash.cpp
		./qbitarray.cpp
		./qatomic.cpp
		./qbytearraylist.cpp
		./qcollator.cpp
		./qcontiguouscache.cpp
		./qelapsedtimer.cpp
		./qhooks.cpp
		./qmath.cpp
		./qrefcount.cpp
		./qscopedpointer.cpp
		./qshareddata.cpp
		./qsharedpointer.cpp
		./qstack.cpp
		./qstringbuilder.cpp
		./qvector.cpp
		./qversiontagging.cpp
		./qqueue.cpp
		./qvsnprintf.cpp
		./qlinkedlist.cpp
		./qsystemerror.cpp
	]
	
	if ^HAVE_GEOM {
		.sources += [
			./qline.cpp
			./qpoint.cpp
			./qrect.cpp
			./qmargins.cpp
			./qsize.cpp
		]
	}
	
	if ^HAVE_URL {
		.sources += [
			./qurl.cpp
			./qtldurl.cpp
			./qurlrecode.cpp
			./qurlidna.cpp
			./qurlquery.cpp
		]
        if target_os == `macos {
             .sources += ./qurl_mac.mm
        }
	}

	if ^HAVE_RE {
		if !trycompile("#include <pcre.h>") {
			error("HAVE_RE required but the pcre headers are not available")
		}
		.sources += ./qregularexpression.cpp
	}
	
	if ^HAVE_JSON {
		.sources += [
			./qjsonarray.cpp  ./qjsondocument.cpp  ./qjsonparser.cpp  ./qjsonwriter.cpp
			./qjson.cpp       ./qjsonobject.cpp    ./qjsonvalue.cpp
		]
	}

	if ^HAVE_XML {
		.sources += [
			./qxmlstream.cpp ./qxmlutils.cpp
		]
	}
	
	if ^HAVE_DSTREAM {
		.sources += ./qdatastream.cpp
	}
	
	if ^HAVE_CMDLINE {
		.sources += [
			./qcommandlineoption.cpp ./qcommandlineparser.cpp
		]
	}
	
	if ^HAVE_FILEIO {
		.sources += [
			./qfile.cpp
			./qdir.cpp
			./qfileinfo.cpp
			./qfiledevice.cpp
			./qfilesystemengine.cpp
			./qfilesystementry.cpp
			./qabstractfileengine.cpp
			./qtemporaryfile.cpp
			./qfsfileengine.cpp
			./qringbuffer.cpp 
			./qfsfileengine_iterator.cpp
			./qdiriterator.cpp
			./qstandardpaths.cpp
			./qlibraryinfo.cpp
			./qsettings.cpp
			./qlockfile.cpp
			./qsavefile.cpp
			./qresource.cpp
			./qresource_iterator.cpp
			./qtemporarydir.cpp
			./qfileselector.cpp
		]
		if target_os == `win32 {
			.sources += [ ./qfilesystemengine_win.cpp ./qfsfileengine_win.cpp ./qfilesystemiterator_win.cpp 
						  ./qstandardpaths_win.cpp ./qsettings_win.cpp ./qlockfile_win.cpp ]
		}else{
		    .sources += [ ./qfilesystemengine_unix.cpp ./qfsfileengine_unix.cpp ./qfilesystemiterator_unix.cpp ./qlockfile_unix.cpp ]
			if target_os == `macos {
				.sources += [ ./qstandardpaths_mac.mm ./qsettings_mac.cpp ]
		    }else{
		        .sources += ./qstandardpaths_unix.cpp
		    }
		}
	}
	
	if ^HAVE_LIBRARY {
		.sources += [
			./qlibrary.cpp
			./qelfparser_p.cpp
			./qmachparser.cpp
		]
		if target_os == `win32 {
			.sources += ./qlibrary_win.cpp
		}else{
			if target_os == `macos {
			}else{
			}
			.sources += ./qlibrary_unix.cpp
		}
		
	}
	
	if ^HAVE_COREAPP {
		.sources += [
			./qcoreapplication.cpp
			./qtranslator.cpp
		]
		if target_os == `win32 {
			.sources += ./qcoreapplication_win.cpp
		}else if target_os == `macos {
			.sources += ./qcoreapplication_mac.cpp
		}
	}
	
	if ^HAVE_PROCESS {
		.sources += ./qprocess.cpp
		if target_os == `win32 {
			.sources += [
				./qprocess_win.cpp
				./qwindowspipereader.cpp
				./qwindowspipewriter.cpp
			]
		}else{
			.include_dirs += ../thirdparty/forkfd
			.sources += [ 
				./qprocess_unix.cpp
				../thirdparty/forkfd/forkfd.c
			]
		}
	}

	if ^HAVE_THREADS {
		.sources += [
			./qthread.cpp
			./qreadwritelock.cpp
			./qmutex.cpp
			./qthreadstorage.cpp
			./qthreadpool.cpp
			./qrunnable.cpp
			./qexception.cpp
			./qmutexpool.cpp
			./qresultstore.cpp
			./qsemaphore.cpp
		]
		if ^HAVE_COREAPP && ^HAVE_OBJECT {
			.sources += [ ./qfuturewatcher.cpp ./qfutureinterface.cpp ]
		}
		if target_os == `win32 {
			.sources += [ ./qthread_win.cpp ./qwaitcondition_win.cpp ]
		}else{
			.sources += [ ./qthread_unix.cpp ./qwaitcondition_unix.cpp ]
		}
	}

	if target_os == `linux {
		.sources += [ 
			./qtimezoneprivate_tz.cpp
			./qlocale_unix.cpp
			./qatomic_unix.cpp
			./qcollator_posix.cpp
			./qcore_unix.cpp
			./qelapsedtimer_unix.cpp
		]
	}else if target_os == `win32 {
		.sources += [ 
			./qsystemlibrary.cpp
			./qwindowscodec.cpp
			./qlocale_win.cpp
			./qcollator_win.cpp
			./qelapsedtimer_win.cpp
			./qtimezoneprivate_win.cpp
			./qsimd.cpp
		]
		if target_toolchain == `msvc {
			.sources += [
				./qvector_msvc.cpp
			]
		}
	}else if target_os == `macos {
        .sources += [
            ./qelapsedtimer_mac.cpp
            ./qdatetime_mac.mm
            ./qlocale_mac.mm
            ./qstring_mac.mm
            ./qtimezoneprivate_mac.mm
            ./qcollator_macx.cpp
            ./qcore_mac.cpp
            ./qcore_mac_objc.mm
 	     ./qcore_unix.cpp
       ]
    }
    
    if ^HAVE_OBJECT {
		# includes events which don't seem to make sense without QObject
		.sources += [
			./qcoreevent.cpp
			./qobject.cpp
			./qmetaobject.cpp
			./qeventloop.cpp
			./qabstracteventdispatcher.cpp
			./qsocketnotifier.cpp
			./qbasictimer.cpp
			./qtimer.cpp
			./qfreelist.cpp
			./qabstractnativeeventfilter.cpp
		]
		if ^HAVE_FILEIO {
			.sources += [ 
				./qfilesystemwatcher.cpp
				./qfilesystemwatcher_polling.cpp
			]
			if target_os == `win32 {
				.sources += [ ./qfilesystemwatcher_win.cpp ]
			}else if target_os == `macos {
				.sources += [  
					./qfilesystemwatcher_kqueue.cpp
					./qfilesystemwatcher_fsevents.mm
				]
			}else{
				.sources += [ ./qfilesystemwatcher_inotify.cpp ]
			}
		}
		if target_os == `win32 {
			.sources += [ 
				./qeventdispatcher_win.cpp 
				./qwineventnotifier.cpp 
			]
		}else{
			if target_os == `macos {
				.defines += "QT_NO_EVENTFD"
				.sources += [ ./qeventdispatcher_cf.mm ./qcfsocketnotifier.cpp ]
			}
			.sources += [ 
				./qeventdispatcher_unix.cpp 
				./qtimerinfo_unix.cpp
			]
		}
	}else{
		.sources += [
			./NoObject.cpp
		]
	}
	

	.configs += [ core_config lib_config ]
}

let run_moc1 : LuaScriptForeach {
	.script = abspath() + ../tools/execute.lua
	let name = "{{source_name_part}}"
	.args += [
		tostring( root_build_dir + ./tools/moc/moc )
		"{{source}}"
		"-b"
		name + "_p.h"
		"-p"
		"{{source_dir}}"
		"-o"
		tostring( root_build_dir + relpath() + topath("moc_"+name+".cpp") )
	]
	.sources += [
		./qbuffer.h
		./qobject.h
		./qthread.h
		./qiodevice.h
		./qcoreapplication.h
		./qeventloop.h
		./qabstracteventdispatcher.h
		./qthreadpool.h
		./qlocale.h
		./qfuturewatcher.h
		./qtranslator.h
	]
	if ^HAVE_FILEIO {
		.sources += [ 
			./qfileselector.h 
			./qfile.h
			./qfiledevice.h
			./qsettings.h
			./qsavefile.h
			./qtemporaryfile.h
			./qfilesystemwatcher.h
		]
	}
	if ^HAVE_LIBRARY {
		.sources += ./qlibrary.h
	}
	if ^HAVE_PROCESS {
		.sources += ./qprocess.h
	}
}

let run_moc2 : LuaScriptForeach {
	.script = abspath() + ../tools/execute.lua
	let name = "{{source_name_part}}"
	.args += [
		tostring( root_build_dir + ./tools/moc/moc )
		"{{source}}"
		"-p"
		"{{source_dir}}"
		"-o"
		tostring( root_build_dir + relpath() + topath("moc_"+name+".cpp") )
	]
	.sources += [
		./qtextstream_p.h
		./qnamespace.h
		./qsocketnotifier.h
		./qtimer.h
	]
	if target_os == `win32 {
		.sources += [ ./qeventdispatcher_win_p.h ./qwineventnotifier.h ]
	}else {
		if target_os == `macos {
			.sources += [ ./qeventdispatcher_cf_p.h ]
		}
		.sources += [ ./qeventdispatcher_unix_p.h ]
	}
	if ^HAVE_FILEIO {
		.sources += [ 
			./qfilesystemwatcher_p.h
			./qfilesystemwatcher_polling_p.h
		]
		if target_os == `win32 {
			.sources += [ ./qfilesystemwatcher_win_p.h ]
		}else if target_os == `macos {
			.sources += [ ./qfilesystemwatcher_kqueue_p.h ./qfilesystemwatcher_fsevents_p.h ]
		}else{
			.sources += [ ./qfilesystemwatcher_inotify_p.h ]
		}
	}
}

let moced_sources * : SourceSet {
	let dir = root_build_dir + relpath()
	.sources += [
		dir + ./moc_qbuffer.cpp
		dir + ./moc_qobject.cpp
		dir + ./moc_qthread.cpp
		dir + ./moc_qiodevice.cpp
		dir + ./moc_qcoreapplication.cpp
		dir + ./moc_qeventloop.cpp
		dir + ./moc_qabstracteventdispatcher.cpp
		dir + ./moc_qthreadpool.cpp
		dir + ./moc_qlocale.cpp
		dir + ./moc_qtextstream_p.cpp
		dir + ./moc_qnamespace.cpp
		dir + ./moc_qsocketnotifier.cpp
		dir + ./moc_qfuturewatcher.cpp
		dir + ./moc_qtimer.cpp
		dir + ./moc_qtranslator.cpp
	]
	if target_os == `win32 {
		.sources += [ 
			dir + ./moc_qwineventnotifier.cpp 
			dir + ./moc_qeventdispatcher_win_p.cpp
		]
	}else {
		if target_os == `macos {
			.sources += [ dir + ./moc_qeventdispatcher_cf_p.cpp ]
		}
		.sources += [ dir + ./moc_qeventdispatcher_unix_p.cpp ]
	}
	if ^HAVE_FILEIO {
		.sources += [ 
			dir + ./moc_qfileselector.cpp 
			dir + ./moc_qfile.cpp
			dir + ./moc_qfiledevice.cpp
			dir + ./moc_qsettings.cpp
			dir + ./moc_qsavefile.cpp
			dir + ./moc_qtemporaryfile.cpp
			dir + ./moc_qfilesystemwatcher.cpp
			dir + ./moc_qfilesystemwatcher_p.cpp
			dir + ./moc_qfilesystemwatcher_polling_p.cpp
		]
		if target_os == `win32 {
			.sources += [ 
				dir + ./moc_qfilesystemwatcher_win_p.cpp 
			]
		}else if target_os == `macos {
			.sources += [ 
				dir + ./moc_qfilesystemwatcher_kqueue_p.cpp 
				dir + ./moc_qfilesystemwatcher_fsevents_p.cpp
			]
		}else{
			.sources += [ 
				dir + ./moc_qfilesystemwatcher_inotify_p.cpp 
			]
		}
	}
	if ^HAVE_LIBRARY {
		.sources += dir + ./moc_qlibrary.cpp
	}
	if ^HAVE_PROCESS {
		.sources += dir + ./moc_qprocess.cpp
	}

	.configs += [ core_config lib_config ]
	.deps += [ run_moc1 run_moc2 ]
}

/*
# not yet supported
qprocess.cpp -> objects, threads, using fileio
qsharedmemory_* -> kernel, used by plugins
qsystemsemaphore_* -> used by shared memory
qwindowspipereader/writer -> used by qprocess_win and qlocalsocket_win
qstorageinfo -> fileio, option
qfactoryloader -> plugins
*/




